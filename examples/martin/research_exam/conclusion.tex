\section{Conclusion}

Throughout this document, we've see several themes emerge.  Longer reads are better.  More sources of data are better, especially if they are close to the donor's genome.  Data structures that capitalize on redundant data are useful.  Partitioning problems into smaller independent problems are useful, either for reducing the memory high watermark or for parallelization (both of which favor large batches of independent work).  Heuristics can be very effective in practice.

One observation is that all of these methods operate oblivious to the content of the genomic data they work with.  A common metaphore for sequence assembly is that of randomly shredding multiple copies of the same book and then trying to reconstruct one copy from the shredded pieces.  For such a task, one could certainly resolve some ambigous reconstruction alternatives by examining the content of the shredded paper for grammatical and semantic correctness.  Perhaps genome content patterns, either captured through statistics or documented in a gene database could be used to augment existing assembly and scaffolding methods to produce better assemblies.

% Can we use other biological priors to aid genome assembly?  Can we machine learn patterns we don't yet understand in the content; current assemblers appear to be content oblivious (though the fact that they have inconsistent ranking in assemblathon 2 could be inadvertent overtraining or bias to ideas that hold true only for some genomes, or they could be the imperfect similarity in the sequencing experiments across the three genomes).  FASTA lacks confidence information. In natural language processing applications, higher level structure can help resolve ambiguities in lower level structure, so lower levels often provide a set of candidates and their estimated probability of being correct. Can we run graph kernels on assembly graphs?  (Are heuristics that test their efficacy on assemblies with know reference genomes already doing this? Are there enough lab finished genomes to provide adequate training data?)  An often used example of genome assembly is that of shredding dozens of copies of the same book and trying to reconstruct a single copy based on matching up the strings.  This completely ignores the fact that the book itself is written in a natural language with semantic functionality and patterns of consistency.
