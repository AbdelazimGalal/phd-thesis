%\section{Discussion and Conclusions}
\label{sec-discussion}

We demonstrate that $\dopp$ is capable of finding the alignment between any pair of  Rmaps in the June plum data set in less than 67 CPU hours whereas the dynamic programming method of Valouev et al.~\cite{Valouev06} requires 1001 hours of CPU time. This latter method computes the optimal alignment between all prefixes of every pair of Rmaps, while our method succeeds in avoiding this exhaustive computation by using an index data structure to narrow the search to consider a smaller set of plausible alignments only. Hence, although, the dynamic programming methods achieve practical running time on small genomes, they are unlikely to scale to large genomes.   As previously mentioned, the first step in building a genome wide consensus map from the Rmap data is to compute the pairwise alignment among Rmaps, and this is the primary motivation for the development of $\dopp$. This pairwise alignment step is the main computational bottleneck in the consensus map building tool of Valouev et al., and $\dopp$ could easily be substituted for their dynamic programming alignment method, to efficiently compute the consensus map for large genomes, such as plum. 

%In fact, the main goal of the work of Valouev et al. is to build a consensus optical map and its first step---which is the bottleneck in achieving this goal---is to compute the alignment between any pair of Rmaps.  Hence, $\dopp$ could easily be substituted for their dynamic programming alignment method, which would result in an efficient means to compute the consensus map for large genomes, such as plum.  

Taking a broader view, $\dopp$ is simply an error-tolerant index-based alignment program that could have additional purposes beyond Rmap data.  For example, one interesting application of this work would be to align {\em in silico} digested long (PacBio) reads to a genome wide optical map, or to the Rmaps.  This complements the work of  Pendleton et al. \cite{ali}, which scaffolds PacBio data using BioNano Irys data.  Our alignment method could be used to assemble or preprocess PacBio reads that have large errors and should undergo error correction, or to isolate regions in the reads that should undergo error correction.  
%SJP: taking this last part out, I think we make out point already, earlier in the paragraph, and don't need to quote statistics of PacBio, which everyone knows anyway. %The PacBio RS technology generates extremely long reads ($\geq$1,000 bp), but with high single-pass error rates (15\% error rate), and correction of these reads is widely regarded as computationally expensive.  This proposed filtering step could make the error correction process more efficient.  

%We conclude by stating that, in addition to this specific use of $\dopp$ there are many other applications yet to be defined and explored.

%The method presented here occupies a middle ground where missing sites in the target are accomodated by combining fragments in the query and missing sites in the query are accomodated by combining vertex labels in the target automaton. Techniques that accomodate both sets of missing sites in only the query processing or encoded only in the target database may prove fruitful. 

%Our work illustrates the successful adaptation of modern data structures to Rmap alignment, but there is room for innovation in practice.  Sorting query Rmaps would allow the dominant work (exploring prefix matches which do not extend to full query matches) to be shared among all Rmaps sharing common prefixes.  Secondly, a wavelet tree is traversed both to find a candidate set of substitutions and can also be used for rank/select dictionary queries for the backwards search step. It may be fruitful to design an algorithm that shares rank/select work, making a single pass for both these purposes.  Third, indexing Rmaps bidirectionally and searching both ends results in alignments being found twice.  After using an Rmap as a query, it need not exist in the database, and addressing this would halve the total computational work by reporting alignments only once.
 
%Lastly, optical mapping is a relatively new technology, and thus, with so few algorithms available for working with this data, we feel there remains good opportunities for developing more efficient and flexible methods. Dynamic programming optical map alignment approaches are still important today, as the assembly of the consensus optical maps from the individually imaged molecules often has to deal with missing or spurious restriction sites in the single molecule maps when enzymes fail to digest a recognition sequence or the molecule breaks.  Though coverage is high (e.g. about 1,241 Gb of optical data was collected for the 2.66 Gb goat genome), there may be cases where missing restriction site errors are not resolved by the assembly process.   In these rare cases (only 1\% of alignments reported by SOMA on parrot contain such errors) they will inhibit $\twin$'s ability to find correct alignments.  In essence, $\twin$ is trading a small degree of sensitivity for a huge speed increase, just as other index based aligners have done for sequence data.  Sir\'{e}n et al.~\cite{dag_method} recently extended the Burrows-Wheeler transform (BWT) from strings to acyclic directed labeled graphs and to support path queries. In future work, an adaptation of this method for optical map alignment may allow for the efficient handling of missing or spurious restriction sites.

%I'm not sure if it's punchy, but if all you want to do is know how many approximate matches exist, we can skip the step of converting BWT intervals to original "text" intervals.  There is also the fact that we match all approximate patterns concurrently.  This is the same argument as in BWA which says "Because exact repeats are collapsed on one path on the prefix trie, we do not need to align reads against each copy of the repeat."  In our case, it's not just DNA sequence repeats, but since ORM data has less resolution, there may be multiple non repeat DNA strings that happen to have the restriction enzyme target motif in the same place.
