
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Methods}\label{sec-meods}

We now describe the algorithm behind $\dopp$.
%, and some important implementation details.  
Three main insights enable our index-based aligner for Rmap data: 1) abstraction of the alignment problem to a finite automaton; 2) use of the GCSA for storing and querying the automaton; and 3) modification of backward search to use a wavelet tree in specific ways to account for the Rmap error profile.  %Casting the alignment problem as path matching in a finite automaton allows the first two errors (missing and false cut sites, and missing fragments) to be modelled.  The GCSA is an index-based data structure for storing and querying finite automaton.  The third type of error (inaccuracy in the fragment sizes) is taken into account by the use of the wavelet tree in the backward search algorithm. For simplicity we first describe standard backward search and then show how it can be extended. 

\subsection{Finite Automaton.}

Continuing with the example in the background section, we want to align $\R' = 6,5,3,5$ to $\R''' = 2,4,7,3,5$ and vice versa.  To accomplish this we cast the Rmap alignment problem to that of matching paths in a finite automaton.  A finite automaton is  a directed, labeled graph that defines a \emph{language}, or a specific set of sequences composed of vertex labels.  A sequence is recognized by an automaton if it contains a matching path: a consecutive sequence of vertex labels equal to the sequence. We represent the target Rmaps as an automaton and the query as a path in this context.  
%SJP: I didn't find this intuition at all helpful
%The intuition is as follows: we can construct an automaton where vertices represent compound fragments (groups of fragments), and the language comprises all the legal assignments of fragments to groups.  That is, every fragment of an Rmap is assigned to exactly one group. 

%\paragraph{Backbone}
The automaton for our target Rmaps can be constructed as follows.  First concatenate the $\R_1 \ldots \R_n$ together into a single sequence with each Rmap separated by  a special symbol which will not match any query symbol. Let $\R^*$ denote this concatenated sequence. Hence, $\R^* = [f_{11},..,f_{1m_1}, \ldots, f_{n1},..,f_{nm_n}]$.  Then, construct an initial finite automaton $\A = (V, E)$ for $\R^*$ by creating a set of vertices $v^i_1 .. v^i_m$, one vertex labeled with each fragment length and edges connecting them.% for each Rmap $\R_i$.
Also, introduce to $\A$  a {\em starting vertex} $v_1$ labeled with $\#$ and a {\em final vertex} $v_f$ labeled with the character $\$$.  All other vertices in $\A$ are labeled with integral values.  This initial set of vertices and edges is called the {\em backbone}.  The backbone by itself is only sufficient for finding alignments with no missing cut sites in the query. Figure \ref{fig:example}(a) illustrates the construction of $\A$ for a single Rmap.  The backbone of this automaton is $\#, 2, 3, 4, 5, 6, \$$.  Next, extra vertices (``skip vertices'') and extra edges are added to $\A$ to allow for the automaton to accept all valid queries.  

\paragraph{Skip Vertices and Skip Edges.}
We introduce additional vertices labeled with {\em compound fragments} to allow missing cut sites (first type of error) to be taken into account in querying the target Rmaps.  We refer to these as {\em skip vertices} as they provide alternative path segments which skip past two or more backbone vertices. Thus, we add a {\em skip vertex} to $\A$ for every $o+1$ length run of consecutive vertices in the backbone where $1 < o < order$ and  \emph{order} is the maximum number of consecutive missed cut sites to be accommodated.  First order skip vertices are each labeled with the sum of two consecutive backbone vertices.  Second order skip vertices are each labeled with the sum of three consecutive backbone vertices. The vertex labeled with $7$ connecting $2$ and $5$ in \ref{fig:example}(a) is an example of a skip vertex.  Likewise, $5, 9, 11$ are other skip vertices.

%The final state of a $\A$, then must additionally have a vertex for each proper compound fragment, such that all combinations are compactly encoded as paths from $v_1$ to $v_s$ in $\A$.


%\paragraph{Edges}
%In this automaton model, vertices represent compound fragments and edges represent restriction sites. Every restriction site in original target Rmaps is potentially conserved in aligning Rmap but the preceding and following sites may not be.  Thus, there will be multiple edges in our automaton corresponding to that site for every site in the original Rmap data: those joining two backbone vertices (edge $4 \rightarrow 5$), those joining skip vertices to backbone vertices (edges $5 \rightarrow 4$ and $3 \rightarrow 9$), and those joining skip vertices to each other (edge $5 \rightarrow 9$).  All matching paths that include one of the aforementioned edges conserve the cut site delimiting fragments $3$ and $4$ in the original Rmap.  
%For every site there will be a complete bipartite subgraph such that to match all possible missing site errors, an automaton will have $O(\ell \delta^2)$ edges, where $\ell$ is the concatenation of all Rmaps in the target and $\delta$ is the order.

Finally, we add {\em skip edges} which provide paths around vertices with small labels in the backbone.
%The dashed edges in figure \ref{fig:example} are the skip edges, which
These allow a query with a missing fragment to still match.\footnote{Different smallness thresholds for query and target bias toward this scenario, avoiding backtracking in the search.}  Hence, the addition of skip edges allow for desorption (the second type of error) to be taken into account in querying the target Rmaps.  


%This graph construction allows for any combination of missing and spurious restriction sites as well desorbed fragments.  As we explain below, when the automaton is indexed appropriately, inaccuracies in the fragment sizes (third type of error) can be handled efficiently, too. % I added the reason mid paragraph that occured at the end, maybe revert this change? -mm It reads well. - sjp
% are handled by using a {\em wavelet tree}.  The wavelet tree and the space succinct data structure used to implement the finite automaton for the  detection of alignments will be discussed in the next section.

\subsection{The Rmap Alignment Score.}

Alignments are found by incrementally extending candidate partial alignments (paths in the automaton) to longer partial alignments by choosing one of several compatible extension matches (adjacent vertices to the end of a path in the automaton).  To perform this search efficiently, we prune the search by a scoring model that scores the size agreement of the matched compound fragments, and the frequency of putative missing cut sites.

\paragraph{Size Agreement.}
We use the Chi-square CDF statistic to assess size agreement.  This assumes the fragment size errors are independent, normally distributed events.  For each pair of matched compound fragments in a partial alignment, we take the average between the two as the assumed true length and
% of the DNA that was measured.  Then we 
compute the expected standard deviation using this mean.  Each compound fragment deviates from the assumed true value by half the distance between them.  These two deviation values contribute two degrees of freedom to the Chi-square calculation.
%FIXME: include this as a formula

\paragraph{Cut Site Error Frequency.}
We use the Binomial CDF statistic to assess the probability of the number of cut site errors in a partial alignment.   This assumes missing cut site errors are independent, Bernoulli processes events.  We account for all the putatively conserved cut sites on the boundaries and those delimiting compound fragments in both partially aligned Rmaps plus twice the number of missed sites as Bernoulli trials. % Since our method handles both missing and false cuts, and false cuts are less frequent with common enzymes, we assume this scoring method is a sufficient approximation of the underlying process to work for our search.
%FIXME: include this as a formula

Thus, given a set of Rmaps and input parameters $\rho_{L}$ and $\rho_{U}$, we produce the set of all Rmap alignments that have a chi-square CDF statistic less than $\rho_U$ and a binomial CDF statistic less than $\rho_L$.  Both of these are subject to the additional constraint of a maximum consecutive missed restriction site run between aligned sites of $\delta$ and a minimum aligned site set cardinality of 16. 

