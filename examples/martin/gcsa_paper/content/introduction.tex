
%Even with significantly high coverage and various insert sizes, genome assembly and structural variation detection are tenuous computational processes when only short read sequence data is used due to the repetitive nature of genomes.  In 2011, Alkan et al. \cite{Alkan:2011} studied the genome assemblies of a Han Chinese individual and a Yoruban individual generated from short read sequence data, and they found that these assemblies were 16\% shorter than the reference genome. Furthermore, they found that 420.2 Mbp of common repeats and 99.1\% of validated duplicated sequences were missing from the genome. In fact, over 2,377 coding exons were completely missing from these draft genomes.  Several years later, Ilie et al.~\cite{SAGE} and Muggli et al.~\cite{ismb2015} detected that these misassembled regions were just as numerous even after genome assemblers became more advanced.  

%Genome-wide optical maps, which are ordered high-resolution restriction maps that indicate the positions of occurrence of one or more short nucleotide sequences, are one type of data that can aid the detection of misassembled region. The system that produces the raw optical mapping data works as follows~\cite{ORMenc,microfluidic}: an ensemble of DNA molecules adhered to a charged glass plate are elongated by fluid flow. An enzyme is then used to cleave them into fragments at loci where the enzyme's recognition sequence occurs. Next, the remaining fragments are highlighted with fluorescent dye and digitally photographed under a microscope. Finally, these images are analyzed to estimate the fragment sizes, producing a molecular map. Since the fragments stay relatively stationary during the aforementioned process, the images capture their relative order and size~\cite{Neely11}.   Multiple copies of the genome undergo this process, producing an optical map for every molecule.  These single molecule maps are referred to as {\em Rmaps}.  Rmaps can be assembled into a genome-wide optical map as a consensus of Rmaps.  A genome-wide optical map provides the approximate number of bases between occurrences of the enzyme recognition sequence within each chromosome of the genome \cite{Anantharaman01}.

There is a current resurgence in generating diverse types of data, to be used alone or in concert with short read data, in order to overcome the limitations of short read data.  Data from an optical mapping system~\cite{ORMenc,microfluidic} is one such example and has itself become more practical with high-throughput methods.  For example, the current BioNano Genomics Irys System requires one week and \$1,000 USD to produce the Rmap data for an average size eukaryote genome, whereas, it required \$100,000 and six months in 2009\footnote{http://www.bionanogenomics.com/press-releases/bionano-genomics-launches-irys-a-novel-platform-for-complex-human-genome-analysis/}. These technological advances and the demonstrated utility of optical mapping in genome assembly~\cite{reslewic,zhou,zhou2,amborella,GOAT} have driven several recent tool development efforts~\cite{optima,omblast,maligner}.
%, including the work of Verzotto et al.~\cite{optima}, Leung et al.~\cite{omblast}, and Mendelowitz et al.~\cite{maligner}.

%Unfortunately, even with many recent computational advancements, one fundamental problem related to the use of optical map data has been overlooked: the pairwise alignment of the raw data.  
Genome-wide optical maps are ordered high-resolution restriction maps that give the position of occurrence of the restriction cut sites corresponding to one or more restriction enzymes.  These genome-wide optical maps are assembled using an overlap-layout-consensus approach using  raw optical map data, which are referred to as {\em Rmaps}.  Hence, Rmaps are akin to reads in genome sequencing.  
{\em To date, however, there is no efficient, non-proprietary method for finding pairwise alignments between Rmaps, which is the first step in assembling genome-wide maps.} 

Several existing methods are superficially applicable to Rmap pairwise alignment, however, all programs either struggle to scale to even moderate size genomes or require significant further adaptation to the problem. One of these is the  dynamic programming method of Valouev {\it et al.}~\cite{Valouev06}, which is capable of solving the problem exactly but requires over 100,000 CPU hours to compute the alignments for rice~\cite{valouev2006algorithm}.   Other methods efficiently find initial seed matches and then extend them through more intensive work.  These include OMBlast~\cite{omblast}, OPTIMA~\cite{optima}, and MalignerIX~\cite{maligner}.  They solve a related alignment problem but are unable to accurately find  pairwise alignments.  This is unsurprising since these methods expect either assembled optical maps or \emph{in silico} digested sequence data for one of their inputs, both having a lower error rate than raw Rmaps.  For example, both OMBlast and OPTIMA found only self alignments on simulated {\em E.coli} (see Results).  MalignerDP is an efficient and error tolerant dynamic programming based method.  However, pairwise alignment for assembly requires overlap alignments and except for Valouev {\it et al.}'s tool, all these tools natively find fit alignments and thus are not readily applicable for these purposes.  OPTIMA prescribes an overlap protocol, but requires the user to break up each Rmap into $k$-mers ($k$-length subsequences) and then align this modified data\footnote{See the $\dopp$ website for a script for this. We provide one since one was unavailable on the OPTIMA website.}. Twin~\cite{wabi2014}, also solves a related problem of aligning {\em in silico } digested contigs to an optical map. 
% SOMA~\cite{Nagarajan08} is a method to scaffold short-read assemblies using a optical map and provides a dynamic programming aligner as part of this method but is significantly slower than the me
    


%The main purpose of OMBlast is to find structural variations.  The idea being that you could in-silico digest a reference genome (say human reference) and then take a donor's DNA from a population and identify structural variations of the donor DNA's Rmaps relative to the in-silico digested reference.  Like OPTIMA, they suggest 

%When I ran it on our datasets, it only finds aligments of each Rmap to itself (e.g. Rmap_45 aligns to Rmap_45 (DUH)).

%In theory, the same overlap "method" from OPTIMA could allow it to work better.  That is... chop an Rmap into k-mers as a means to repurpose a "fit" aligner to an "overlap" aligner.  

%In theory, one should be able to just do a few k-mers from each end of an R-map.  This is what we do in DOPPELGANGER.  But neither of these papers discusses that at all.

%Rmaps are typically 30 fragments long.  If we break each into 12-mers and align those, we end up running alignment for ~19 k-mers for each Rmap.  On the simulated E. coli dataset, all pairs alignment is over 2.5x slower than Valouev.

%Well, that's why breaking up a sequence into Rmaps is kinda dumb.  You'd need a blisteringly fast aligner to do all the k-mers.  Given that they don't provide any code to do it, and the overall feeling I get from the development of ideas in the paper, it seems like it's an afterthought-hack with their method.


%they state ``...their  [Anantharaman et al.]  algorithm had deficiencies in terms of scalability to large genomes. Consequently, application of this algorithm to genome assemblies more complex than bacteria required additional extensive ad hoc approaches. As such, there is a definite need for new algorithms that are specifically designed for handling many computational issues inherent to the assembly of large genomes, such as plant and mammalian.''  While the methods of Valouev et al.~\cite{Valouev06,valouev2006algorithm} may have been motivated by inefficiencies of the method previously described by Anantharaman et al., their own results still showed there is room for further improvement; 

In this paper, we present a fast, error-tolerant method for performing pairwise Rmap alignment that makes use of a novel FM-index-based data structure. The FM-index~\cite{fm2005} itself is key for efficient short read alignment~\cite{BWA,bowtie}, but is difficult to apply directly to Rmap alignment.  This is because of: (1) the Ramp error profile, (2) the fragment sizes require inexact fragment-fragment matches (e.g. 1,547 bp and 1,503 bp represent the same fragment), (3) the Rmap sequence alphabet consists of all unique fragment sizes and is so extremely large (e.g., over 16,000 symbols for the goat genome).  The second two challenges render inefficient the standard FM-index backward search algorithm, which excels at exact matching over small alphabets. The first (and most-notable) challenge requires a more complex index-based data structure be used to create an aligner that is robust for insertion and deletion of cut sites. To overcome these problems, we develop $\dopp$, an index-based Rmap alignment program that is capable of finding all pairwise alignments in large eukaryote organisms.

%make the alignment more akin to the problem of aligning long (e.g. PacBio) reads



\paragraph{\protect{\emph{Our contributions.}}}
We first abstract the problem to that of approximate-path matching in a directed 
acyclic graph (DAG). The $\dopp$ method then indexes a set of Rmaps represented
as a DAG, using a modified form of the {\em generalized compressed suffix array (GCSA)}, which is 
a variant of the FM-index developed by Siren et al.~\cite{dag_method}.  The principle insight of our work is that while GCSA is able to efficiently match all similar paths concurrently, it was designed for indexing variations observed in a collection of sequences; all other variations found in a query sequence are handled in query processing. In contrast, our work introduces speculative variations based on the Rmap error profile into the indexed data.  Lastly, we demonstrate that challenges posed by the inexact fragment sizes and alphabet size can be overcome in the GCSA via careful use of a wavelet tree~\cite{GNPtcs11}. %as we demonstrated in the less error tolerant index of Muggli et al.~\cite{wabi2014}. 

We verify our approach on simulated {\em E. coli} Rmap data\footnote{The Rmap data is available with the download of our method.} by showing that $\dopp$ achieves similar sensitivity and specificity to Valouev et al., and with more permissive alignment acceptance criteria 90\% of Rmaps pairs with known overlapping genomic origin.  Lastly, we show the utility of our approach on larger eukaryote genomes by demonstrating that existing methods require more than 40 days of CPU time to find all pairwise alignments in the plum Rmap data; whereas, $\dopp$ requires less than two days. 

%ical mapping data is being generated at increasing throughput and decreasing cost due to continued technological improvements.  For example,   However, even prior to 2009, optical mapping data showed to be valuable for assembling the genome of a variety of species, including several prokaryote species \cite{reslewic,zhou,zhou2}, {\em Oryza sativa} (rice) \cite{RICE}, maize \cite{Zhou09}, and mouse \cite{church}. Newer technology has bee used to generate data for goat \cite{GOAT}, {\em Melopsittacus Undulatus} (budgerigar) \cite{gigadb}, and {\em Amborella trichopoda} \cite{amborella}.  

%%\section{Related Work} 
%There are several existing optical map alignment methods.  The majority of the existing approaches can be divided into: \emph{fit} aligners that align small optical maps (such as Rmaps or {\em in silico} digested contigs) to a genome-wide optical map, and \emph{overlap} aligners that align Rmaps to each other.  The former aligners are frequently used to validate or scaffold assembled contigs.  $\twin$~\cite{wabi2014} is a fit aligner that uses index-based data structures.  After the release of $\twin$, Mendelowitz et al. \cite{pop_aligner} presented malignerIX, which is another index-based aligner that aligns {\em in silico} digested contigs to a genome-wide optical map.  They demonstrate that the efficiency of malignerIX is comparable to $\twin$ but that it produces more accurate alignments.  Both malignerIX and $\twin$ are orders of magnitude faster than dynamic programming aligners but are not suitable for aligning Rmap data due to the error profile of this raw data. %Mendelowitz et al. also describe a graph with speculative errors, however they follow a seed and extend approach where each candidate alignment must be iteratively exhausted serially while the GCSA index allows all similar candidate matches to be exhausted concurrently.

%Gentig~\cite{Anantharaman01}, the software developed by Valouev et al.~\cite{Valouev06,valouev2006algorithm}, SOMA~\cite{Nagarajan08} and malignerDP  \cite{pop_aligner} are capable of aligning Rmap data.  All methods largely use dynamic programming.  SOMA~\cite{Nagarajan08} is, in fact, a method to scaffold short-read assemblies using a genome-wide optical map; however,  SOMA provides a method for scaffolding in addition to their $O(n^2 m^2)$-time dynamic programming algorithm, the latter part of this package would be capable of aligning Rmap data. Gentig~\cite{Anantharaman01}, and software developed by Valouev et al.~\cite{Valouev06,valouev2006algorithm} also use dynamic programming to address the closely related task of finding alignments between optical maps. Gentig is not available for download.  In 2015, malignerDP  \cite{pop_aligner} was developed to improve upon the dynamic programming approach of SOMA by a.) bounding the number of consecutive missed cut sites (as does the aligner by Valouev et al.) and b.) evaluate alignment significance using all non-overlapping alignments discoverable from a dynamic programming matrix in place of SOMA's expensive permutation test. They compare their method against SOMA and $\twin$ and demonstrate it significantly improves on the efficiency of SOMA.  At the present moment, there does not exist any index-based methods to align Rmap data.  


%BACop~\cite{Zhou09} also uses a dynamic programming algorithm and corresponding scoring scheme that gives more weight to contigs with higher fragment density. Antoniotti et al.~\cite{antoniotti} consider the problem of validating an optical map by using assembled contigs. This method assumes the contigs are error-free. 
%Optical mapping data was produced for Assemblathon 2~\cite{bradnam2013assemblathon}. % parrot, not goat or ostrich -mm









