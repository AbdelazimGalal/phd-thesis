\section{Background}
\label{sec-background}

%% FIXME: we're using lowercase sigma for both variance and alphabet size indiscriminantely

\paragraph{Basic Definitions.}
Throughout we consider a string (or sequence) $S = S[1..n] = S[1]S[2]\ldots$ $S[n]$ of $|S| = n$ 
symbols drawn from the alphabet $[0..\sigma-1]$.
%We assume $\X[n]$ is a special ``end of string'' symbol, \$, smaller than
%all other symbols in the alphabet.
For $i=1,\ldots,n$ we
write $S[i..n]$ to denote the {\em suffix} of $S$ of length $n-i+1$,
that is $S[i..n] = S[i]S[i+1]\ldots S[n]$, and  
%We will often refer to suffix $\X[i..n]$ simply as ``suffix $i$''. 
$S[1..i]$ to denote the {\em prefix} of $S$ of length $i$.
$S[i..j]$ is the {\em substring} $S[i]S[i+1]\ldots S[j]$ of $S$
that starts at position $i$ and ends at $j$. 
Given a sequence $S[1,n]$ over an alphabet $\Sigma =
\{1,\ldots,\sigma\}$, a character $c \in \Sigma $, and integers
$i$,$j$, $\rank_c(S,i)$ is the number of times that $c$ appears in
$S[1,i]$, and $\select_c(S,j)$ is the position of the $j$-th
occurrence of $c$ in $S$.
%By $\X[i..j)$ we
%denote $\X[i..j-1]$.  If $j < i$ we
%define $\X[i..j]$ to be the empty string, also denoted by
%$\varepsilon$.

%FIXME: we don't mention false cuts in the above.

%\paragraph{Pairwise Rmap Alignment.} One significant challenge in aligning one Rmap to another is overcoming missing fragments and missing cut sites. This challenge is analogous to dealing with insertion and deletions in the alignment of long reads---in fact, it is arguably harder since the data is integral and susceptible to inaccuracy.  Continuing on from our example above, we need to be able to align $\R' = 7,6,3,4.$ to $\R = 2,4,5,3,5.$ and vice versa.  It will be useful to cast this Rmap alignment problem to matching paths in a finite automaton.   A finite automaton $A = (V, E)$ is built for a set of Rmaps $\R_1..\R_k$ by creating a set of vertices $v^i_1 .. v^i_m$ and edges for each Rmap $\R_i$.  $\A$ contains a {\em starting vertices} $v_1$ labeled with $\#$ and a {\em final vertex} $v_f$ labeled with the character $\$$.  All other vertices in $\A$ are labeled with integral values.   We note that in the most basic form a finite automaton is  a directed, labeled graph that defines a language to be recognized by the sequences that are recognized by the automaton; a sequence is recognized by a automaton if there exists a path {\em matching} the sequence in the automaton.   
% 
%For each $\R_i$ we consider all combinations of missing fragments and create a path from $v_1$ to $v_s$ in $\A$.  We refer to the {\em backbone} of $\A$ as the path corresponding to the sequence containing no missing fragments. We refer to the {\em skip vertices} in $\A$ as those connecting vertices in the backbone.  Figure \ref{fig:example} illustrates the construction of $\A$ for a single Rmap and only one missing fragment.  The backbone of this automaton is $\#, 3, 18, 4, 17, 23, 83, 6, \$$ and $22$ connecting $3$ and $17$ is an example of a skip vertex.  Likewise, $21, 21, 40, 89, 106$ are other skip vertices. Hence, the skip nodes enable us to handle missing cut sites (the first type of error).  In addition, we add {\em skip edges} which join to vertices in the backbone.  The dashed edges in figure \ref{fig:example} are the skip edges, which allow us to handle missing fragments (the second type of error).  Inaccuracies in the fragment sizes (third type of error) are handled by using a {\em wavelet tree}.  The wavelet tree and the space succinct data structure used to implement the finite automaton for the  detection of alignments will be discussed in the next section. 
%
%\begin{figure*}[h!]
%  \centering
%  \includegraphics[width=\textwidth]{./content/figures/example_2}
%  \caption{An illustration of a finite automaton that constructed for a small number of of Rmaps.  The backbone vertices are $\#, 3, 18, 4, 17, 23, 83, 6, \$$.  The skip vertices are  $21, 22, 21, 40, 89, 106$ in this example and the skip edges are the dashed edges.  There is a skip edge that allow the omission of fragments of size less than or equal to 6.}
%\label{fig:example}
%\end{figure*}
%


%See XX for a more thorough discussion of finite automatons and the language accepted by them.

%The approximate mean and standard deviation of the fragment size error rate in the Rmap for current data \cite{error_rate} are XX and XXbp, respectively.  
%The standard deviation between pairs of raw optical maps appears to be about 2.5 Kbp, which I think corresponds to an optical measurement error of half that, or 1.25 Kbp.  I expect the 150 bp number Christina got from BioNano is so much better because it's for a consensus map, where the errors tend to cancel each other out due to the law of large numbers, and/or more modern technology and/or different technology.

%TODO: 1) check the above makes sense 2) mention that in practice there are errors, 3) illustrate the alignment problem with an example.


%\subsection{Rank and Select}
%\label{sec:rank}
%Two basic operations
%used in almost every succinct and compressed data structure are {\em rank} and
%{\em select}. 
\subsubsection{Overview of Optical Mapping.} \label{data_description}

From a computer science viewpoint, restriction mapping (by optical or other means) can be seen as a process that takes in two
sequences: a genome $\A[1,n]$ and a restriction enzyme's recognition sequence $\B[1,b]$, and produces an array (sequence) of integers 
$\C$, the {\em genome restriction map}, which we define as follows. First define the array of integers $\C[1,m]$ where $\C[i] = j$ if and only if 
$\A[j..j+b] = \B$ is the $i$th occurrence of $\B$ in $\A$.
Then $\R[i] = (\C[i]-\C[i-1])$, with $\R[1] = \C[1]-1$.
In words, $\R$ contains the distance between occurrences of $\B$ in $\A$.
For example, if we let $\B = \mbox{{\em act}}$ and 

\begin{center}
  {\setlength{\tabcolsep}{4.5pt}
  {\footnotesize
	\begin{tabular}{p{0.3cm}*{22}{p{0.03cm}}}
		& $\scriptstyle 1 $& $\scriptstyle 2 $& $\scriptstyle 3$& $\scriptstyle 4 $& $\scriptstyle 5 $& 
		$\scriptstyle 6 $& $\scriptstyle 7 $& $\scriptstyle 8 $& $\scriptstyle 9 $& $\scriptstyle 10$&
		$\scriptstyle 11 $& $\scriptstyle 12 $& $\scriptstyle 13$& $\scriptstyle 14 $& $\scriptstyle 15 $& 
		$\scriptstyle 16 $& $\scriptstyle 17 $& $\scriptstyle 18 $& $\scriptstyle 19 $& $\scriptstyle 20$&
		$\scriptstyle 21 $& $\scriptstyle 22 $\\
		$\A = $& $a$ & $t$ & $a$ & $c$ & $t$ & $t$ & $a$ & $c$ & $t$ & $g$ & $g$ 
		&      $a$ & $c$ & $t$ & $a$ & $c$ & $t$ & $a$ & $a$ & $a$ & $c$ & $t$ \\
	\end{tabular}
  }
  }
\end{center}

\noindent then we would have $\C = 3,7,12,15,20$ and $\R = 2,4,5,3,5$.  

In reality, $\R$ is a consensus sequence formed from millions of erroneous Rmap sequences.
The optical mapping system produces millions of Rmaps for a single genome. It is performed on many cells of the organism and for each cell there are thousands of Rmaps (each at least 250 Kbp in length in publicly available data).
%This is analogous to next generation sequencing.
The Rmaps are then assembled to produce a genome-wide optical map.
Like the final $\R$ sequence, each Rmap is an array of lengths --- or fragment sizes --- between occurrences of $\B$ in $\A$.
% (equivalently differences between adjacent values in $\M$). More formally, we define a Rmap  $\R[1,m]$ where $\R[i] = (\M[i]-\M[i-1])$, with $\R[1] = \M[1]-1$.  Continuing with the example above, we have $\R = 2,4,5,3,5.$  

There are three types of errors that an Rmap (and hence with lower magnitude and frequency, also the consensus map) can contain: (1) missing and false cuts, which are caused by an enzyme not cleaving at a specific site, or by random breaks in the DNA molecule, respectively; (2) missing fragments that are caused by {\em desorption}, where small ($ < 1$ Kbp ) fragments are lost and so not detected by the imaging system; and (3) inaccuracy in the fragment size due to varying fluorescent dye adhesion to the DNA and other limitations of the imaging process.  Continuing again with the example above where $\R = 2,4,5,3,5$ is the error-free Rmap: an example of an Rmap with the first type of error could be $\R' = 6,5,3,5$ (the first cut site is missing so the fragment sizes 2, and 4 are summed to become 6 in $\R'$); an example of a Rmap with the second type of error would be $\R'' = 2,4,3,5$ (the third fragment is missing); and lastly, the third type of error could be illustrated by $\R''' = 2,4,7,3,5$ (the size of the third fragment is inaccurately given).  
%Hence, a more accurate Rmap for this small example would be something like $\R = 7,6,3,4.$  
\paragraph{Frequency of Errors.} In the optical mapping system, there is a 20\% probability that a fragment is missed and a 0.15\% probability of a false break per Kbp, i.e., error type (1) occurs in a fragment.  Popular restiction enzymes in optical mapping experiments recognize a 6 bp sequence giving an expected cutting density of 1 per 4096 bp.  At this cutting density, false breaks are less common than missing restriction sites (approx. $0.25 * .2 = .05$ for missing sites vs. 0.0015 for false sites per bp).  The inaccuracy of the fragment sizes, i.e, error type (3), follows a normal distribution with mean and variance assumed to be 0 bp and $\ell \sigma^2$ ($\sigma = .58$ kbp), respectively~\cite{Valouev06}. % FIXME .58 is in the corresponding software, their subsequent publication on the valouev assembler gives a numerical in agreement with this if it's not in this paper -mm
%%%%%%%%%%%%%%%%

 
\paragraph{Suffix Arrays, BWT and Backward Search.}
The suffix array~\cite{mm1993} $\SA_{\X}$ (we drop subscripts when
they are clear
from the context) of a sequence $\X$
is an array $\SA[1..n]$ which
contains a permutation of the integers $[1..n]$ such that $\X[\SA[1]..n]
< \X[\SA[2]..n] < \cdots < \X[\SA[n]..n]$.  In other words, $\SA[j] =
i$ iff $\X[i..n]$ is the $j^{\mbox{{\scriptsize th}}}$ suffix of $\X$
in lexicographic order. For a sequence $\Y$, the $\Y$-interval in the suffix array $\SA_{\X}$ is
the interval $\SA[s..e]$ that contains all suffixes having $\Y$ as a
prefix. The $\Y$-interval is a representation of the occurrences of
$\Y$ in $\X$. For a character $c$ and a sequence $\Y$, the computation
of $c\Y$-interval from $\Y$-interval is called a \emph{left extension}.
%and the computation of $\Y$-interval from ${\Y}c$-interval is called a
%\emph{right contraction}. \emph{Left contraction} and \emph{right
%  extension} are defined symmetrically.

The Burrows-Wheeler Transform $\BWT[1..n]$ is a
permutation of $\X$ such that $\BWT[i] = \X[\SA[i]-1]$ if $\SA[i]>1$
and $\$$ otherwise \cite{bw1994}. We also define $\LF[i] = j$ iff $\SA[j] =
\SA[i]-1$, except when $\SA[i] = 1$, in which case $\LF[i] = I$,
where $\SA[I] = n$.  Ferragina and Manzini~\cite{fm2005} linked $\BWT$ and $\SA$ in the
following way.  
Let $\C[c]$, for symbol $c$, be the number of symbols
in $\X$ lexicographically smaller than $c$.  The function
$\rank(\X,c,i)$, for sequence $\X$, symbol $c$, and integer $i$, returns
the number of occurrences of $c$ in $\X[1..i]$.  It is well known that
$\LF[i] = \C[\BWT[i]] + \rank(\BWT,\BWT[i],i)$.  Furthermore, we can
compute the left extension using $\C$ and $\rank$.  If $\SA[s..e]$ is
the $\Y$-interval,
%containing all the suffixes prefixed with string $\Y$, 
then
$\SA[\C[c]+\rank(\BWT,c,s),\C[c]+\rank(\BWT,c,e)]$ is
the $c\Y$-interval.
This is called \emph{backward search}~\cite{fm2005}, and a data
structure supporting it is called an {\em FM-index}.

To support rank queries in backward search, a data structure called a {\em wavelet tree} (see~\cite{GNPtcs11}) 
can be used. It occupies $n\log\sigma + o(n\log\sigma)$
bits of space and supports $\rank$ queries in $O(\log\sigma)$ time.
Wavelet trees also support a variety of more complex queries on the underlying string  efficiently (see, e.g.~\cite{GNPtcs11}). 
One such query we will use in this paper 
%{\em range alphabet}, $\ralpha(i,j)$, which returns the set 
is to return the set $X$ of 
distinct symbols occurring in $S[i,j]$, which takes
%Wavelet trees support $\ralpha$ queries in 
$O(|X|\log\sigma)$ time.

