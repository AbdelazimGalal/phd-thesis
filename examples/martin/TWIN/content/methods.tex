
\section{Methods}
\label{sec-methods}

% add SA stuff

%%%%%% overview that gives high level view in a logical (not chronological) order %%%%%%

We find alignments in four steps.  First, we convert contigs from the sequence domain to the optical map domain through the process of {\em in silico} digestion. Second, an FM-index is built from the sequence of optical map fragment sizes. Third, we execute a modified version of the FM-index backward search algorithm described in Section~\ref{sec-background} that allows inexact matches.
As a result of allowing inexact matches, there may be multiple fragments in an optical map that could each be a reasonable match for an {\em in silico} digested fragment, and in order to include all of these as candidate matches, backtracking becomes necessary in the backward search.
For every backward search path that maintains a non-empty interval for the entire query contig, we emit the alignments denoted by the final interval.%, mapped back to a position in the optical map.
%Additionally, we found that allowing backtracking for all reasonable matches can cause poor runtime performance, as the branching factor in the backtracking search can approach the entire tolerance range when used with larger genomes.
%This is because larger genomes tend to have a comprehensive distribution of fragment sizes and covering the entire tolerance range.  
%To address this problem, we reduce the number of candidates that must be considered by quantizing all optical map fragments into bins as part of the FM-index construction process.  


\subsection{Converting Contigs to the Optical Map Domain}
%%%%%%%%%%%% contig prep %%%%%%%%%%%%%%%%

In order to find alignments for contigs relative to the optical map, we must first convert the strings of bases into the domain of optical maps, that is, strings of fragment sizes.
We do this by performing an {\em in silico} digest of each contig, which is performing a linear search over its bases, searching for occurrences of the enzyme recognition sequence and then computing the distances between adjacent restriction sites. 
These distances are taken to be equivalent to the fragment sizes that would result if the contig's genomic region underwent digestion in a lab.  
Additionally, the end fragments of the {\em in silico} digested contig are removed, as the outside ends are most likely not a result of the optical map restriction enzyme digestion, but rather an artifact of the sequencing and assembly process.


\subsection{Building an FM-index from Optical Mapping Data}
\label{subsec-buildfm}
% quantization
% fm-index implementation

% As mentioned above, before building the FM-index, we first quantize the optical map's fragment sizes 
% into fixed sized bins, producing a string, $Z[1,m]$, of these quantized values.
% More precisely, for a bin size parameter choice $\Delta$, 
% $Z[i] = \Delta \lfloor \frac{F[i]}{\Delta} + \frac{1}{2} \rfloor$.
% Thus, the size of the alphabet of $Z$ is at most $\frac{f}{\Delta}$, where $f$ is the maximum fragment size.
%The alphabet, $\sigma$ is composed of symbols representing these bins. 
%SJP: We should express the alphabet in terms of $\Delta$.

%For circular genomes, we concatenate two copies of the optical map allowing contigs that span the genomic region composed of the ends of the optical map to be found. %SJP: took this out because its a minor point.  

We construct the FM-index for $\ell$, the string of 
% quantized
fragment sizes. 
The particular FM-index implementation we use is the SDSL-Lite\footnote{\url{https://github.com/simongog/sdsl-lite}.} \cite{SDSL}
%cite{SDSL} 
library's \emph{compressed suffix array with integer wavelet tree} data structure\footnote{The exact revision we used was commit ae42592099707bc59cd1e74997e635324b210115.}.
% available on \url{http://github.com}.}.

%Also, in preparation for finding alignments, we construct two auxiliary data structures.  First, we construct a mapping, or lookup table, from ordinal fragment number to the approximate position in the genome by adding up the lengths of fragments preceeding it.  (e.g. The genomic position of the left end of the third fragment is approximately the sum of the lengths of the first and second fragments.) In this way, when an alignment is found between the two strings of fragment sizes which $\twin$ works on, the position in the optical map can be converted to a position in terms of bases within the genome by a simple table lookup.  Second, using the FM-index to map suffix array indices back to indices in the original optical map involves $O(p)$ $\LF$ operations, where $p$ is the so-called sample period of the FM-index. To improve speed, we also compute and store the suffix array of the optical map, which allows a simple lookup of the index found by the backward search to the corresponding position in the optical map. \marginpar{What we're really saying here is that we store SA so that we can access SA[sp..ep] fast.}

In preparation for finding alignments, we also keep two auxiliary data structures. The first is the suffix array, $\SA_{\scriptsize \F}$, corresponding to our FM-index, which we use to report the positions in $\ell$ where alignments of a contig occur. While we could decode the relevant entries of $\SA$ on demand with the FM-index in $O(p)$ time, where $p$ is the so-called sample period of the FM-index, storing $\SA$ explicitly significantly improves runtime at the cost of a modest increase in memory usage. The second data structure we store is $\M$, which allows us to map from positions in $\ell$ to positions in the original genome in constant time.

\subsection{Alignment of Contigs Using the FM-index}
After constructing the FM-index of the optical map, we find alignments between the optical map and the {\em in silico} digested contigs.  


%%%%%%%%%%%% goal %%%%%%%%%%%%%%
Specifically, we try to find substrings of the optical map fragment sequence $\ell$ that are similar to the string of each {\em in silico} digested contig's non-end fragments $F$ satisfying an alignment goodness metric suggested by Nagarajan et al. \cite{Nagarajan08} \footnote{N.B. Alternative goodness metrics could be substituted.  They must satisfy the property that pairs of strings considered to align well are composed of substrings that are also considered to align well would also work.}:
%\marginpar{MM: C/c in this section are different from sec. 2}
\begin{displaymath}
\Bigl \lvert \sum_{i=s}^{t}F_i - \sum_{j=u}^{v}\ell_j \Bigr \rvert \le F_\sigma \sqrt{\sum_{j=u}^{v}\sigma_{j}^{2}},
\end{displaymath}
where a parameter $F_\sigma$  will affect the precision/recall tradeoff.

% some context, may end up being redundant with background

This computation is carried out using a modified FM-index backward search.  
A simplified, recursive version of our algorithm for finding alignments is shown in Algorithm \ref{match}.
The original FM-index backward search proceeds by finding a succession of intervals in the suffix array of the original text that progressively match longer and longer suffixes of the query string, starting from the rightmost symbol of the query.   Each additional symbol in the query string is matched in a process taking two arguments: 1) a suffix array interval, the $\Y$-interval, corresponding to the suffixes in the text, $\ell$, whose prefix matches a suffix of the query string, and 2) an extension symbol $c$.  The process returns a new interval, the $c\Y$-interval, where a prefix of each text suffix corresponding to the new interval is a left extension of the previous query suffix. This process is preserved in $\twin$, and is represented by the function \emph{BackwardSearchOneSymbol} in the $\twin$ algorithm, displayed in Algorithm~\ref{match}.

% using the wavelet tree to find candidates

Since the optical map fragments include error from the measurement process, 
%even before the quantization error we introduce, 
it cannot be assumed an {\em in silico} fragment size will exactly match the optical map fragment size from the same locus in the genome.
To accomodate these differences, we determine a set of distinct candidate match fragment sizes, $D$, each similar in size to the next fragment to be matched in our query. These candidates are drawn from the 
%complete set of fragment sizes that exist anywhere in the optical map. 
 interval of the BWT currently active in our backward search.
We do this by a wavelet tree traversal function provided by SDSL-Lite, which implements the algorithm described in~\cite{GNPtcs11} and takes $O(|D|\log(f/\Delta))$ time. This is represented by the function \emph{RestrictedUniqueRangeValues} in Algorithm~\ref{match}. We emphasise that, due to the large alphabet of $\ell $, the wavelet tree's ability to list unique values in a range efficiently is vital to overall performance. Unlike in other applications where the FM-index is used for approximate pattern matching (e.g. read alignment), we cannot afford a bruteforce enumeration of the alphabet at each step in the backward search.

These candidates are chosen to be within a reasonable noise tolerance, $t$, based on assumptions about the distribution of optical measurement error around the true fragment length.
 Since there may be multiple match candidates in the BWT interval of the optical map for a query fragment, we extend the backward search with backtracking so each candidate size computed from the wavelet tree is evaluated.  That is, for a given {\em in silico} fragment size (i.e. symbol) $c$, every possible candidate fragment size, $c'$, that can be found in the optical map in the range $c - t \ldots c + t$ and in the interval $s \ldots e$ (of the BWT) for some tolerance $t$ is used as a substitute in the backward search. Each of these candidates is then checked to ensure that a left extension would still satify the goodness metric, and then used as the extension symbol in the backward search.  So it is actually a set of $c'\Y$-intervals that is computed as the left extension in $\twin$.  Additionally, small DNA fragments may not adhere sufficiently to the glass surface and can be lost in the optical mapping process, so we also branch the backtracking search both with and without small {\em in silico} fragments to accomodate the uncertainty.
% memoization, this is sort of an optimization, but I didn't observe much change with it
%We do this for every element of the contig's fragments during the backward search.  %However, the computed set of candidates for each query string fragment will be invariant throughout the backward search for a given query, so this is memoized to prevent repeated computation of the same set. 

Each time the backward search algorithm successfully progresses throughout the entire query (i.e. it finds some approximate match in the optical map for each fragment in the contig query), we take the contents of the resulting interval in the $\SA$ as representing a set of likely alignments.

%At each point, we are trying to find the intersection of fragment sizes in the optical map that could be from the same locus as the next fragment of the contig and those that preceed the part of the query up to that point

% quantization

%The cardinality of the set of candidates from the optical map as a match for an {\em in silico} digested fragment can cause a very high branching factor in the backtracking search, which can cripple runtime performance.
% As mentioned in Section~\ref{subsec-buildfm} above,
% we solved this by quantizing the optical map fragments before building the FM-index.
% Without quantization, most symbols (fragment sizes) in $F$ will be unique and the 
% suffix array will probably only be sorted by the first symbol of each suffix.
% Quantization reduces the alphabet (number of distinct fragment sizes) and causes 
% regions of the optical map that have a similar (but, prior to quantization, not identical)
% sequence of fragment sizes to be clustered together in contiguous intervals of the $\SA$,
% conveniently ignoring small differences in size measurement.
% Quantization does add an extra degree of noise to the measurement error already present in fragment size.
% The quantization noise means a wider tolerance is needed when deciding to accept an alignment, and this could result in some spurious alignments being accepted; however, these can be later filtered in linear time as a post-processing step, and anyway our experiments show this is not an issue in practice.


%Then we take the inter restriction site spans in contigs as a the sequence of fragment sizes that would result if the contigs DNA sequence were digested.


%SJP: we say this next bit in the following subsection. No real need to have it here too.
%Each is then converted (using $M$) to the corresponding index in the original optical map fragment sequence and can later be checked for goodness of alignment without quantization.


% empty string, also denoted by $\varepsilon$.

\renewcommand{\algorithmiccomment}[1]{\hskip0em$\triangleright$ #1}

\begin{algorithm}[t]
\caption{{\sc Match}($s$, $e$, $q$, $h$) Provided a suffix array start index $s$ and end index $e$, query string $q$, and rightmost unmatched query string index $h$ (initially $s=1$, $e=m$, $h=|q| - 1$), emit alignments of an \emph{in silico} digested contig to an optical map.}
\label{match}
\begin{algorithmic}

\Procedure{Match}{$s$,$e$,$q$,$h$}
\If{$h = -1$} 
  \State \Comment{Recursion base case.  Suffix array indexes $s .. e$ denote original query matches.}
  \State{ \emph{Emit}$(s, e)$} 
\Else
  \State \Comment{The next symbol to match, $c$, is the last symbol in the query string.}
  \State $c \leftarrow q[h]$ 
  \State \Comment{Find the approximately matching values in $\BWT[s \ldots e]$, within tolerance $t$.}
  \State $D \leftarrow$ \emph{RestrictedUniqueRangeValues}(s, e, $c + t$, $c - t$) 
  \State \Comment{Let $c'$ be one possible substitute for $c$ drawn from $D$}
  \ForAll{$c' \in D$} 
    \State \Comment{If Equation 1 is still satisified with $c' $ and $c$, ...}
    \If{ %(FIXME: equation (1) applied to $c'$ ++  suffix(original $q$) and an arbitrary suffix denoted in $s..e$)
$\Bigl \lvert \sum_{i=0}^{|q|-h}\SA[s]_i + c' - \sum_{j=h}^{|q|-1}q_j - c \Bigr \rvert \le F_\sigma \sqrt{\sum_{j=0}^{|q|-h}\sigma_{j}^{2}}$
    } 
    \State \Comment{... determine the suffix array range of the left extension of $c'$.}
    \State $s', e' \leftarrow$ \emph{BackwardSearchOneSymbol}($s,e,c'$) 
      \State \Comment{Recurse to attempt to match the currently unmatched prefix.}
      \State {\sc Match}($s', e', q, h - 1$) 
    \EndIf
  \EndFor
\EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}


% def match(fm_index, sp, ep, query):
%    if len(query) == 0: emit(sp,ep)
%    candidates = fm_index.wavetree.unique_range_values(query[-1] + tolerance, query[-1] - tolerance)
%    for candidate in candidates:
%        next_sp, next_ep = back ward_search(fm_index, sp, ep, candidate)
%        if next_sp >= next_ep:
%        match(fm_index, next_sp, next_ep, query[:-1])
   
\subsection{Output of Alignments in PSL format}
For each {\em in silico} digested contig that has an approximate match in the optical map, we emit the alignment, converting positions in the fragment string $\ell$ to positions in the genome using the $\M$ table. We provide a script to convert the human readable output into PSL format. %computed in Section~\ref{subsec-buildfm}.
%Since loci in PSL format are in terms of bases, we maintain a mapping from optical map fragment index to genome loci in terms of bases.
